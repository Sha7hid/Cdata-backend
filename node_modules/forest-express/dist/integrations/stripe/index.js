"use strict";

var _require = require('@forestadmin/context'),
  inject = _require.inject;
var _ = require('lodash');
var logger = require('../../services/logger');
var Routes = require('./routes');
var Setup = require('./setup');
function Checker(opts, Implementation) {
  var _inject = inject(),
    modelsManager = _inject.modelsManager;
  var integrationValid = false;
  function upgradeIntegrationInPlace(stripe) {
    // Transform userCollection + userField => mapping
    if (stripe.userCollection || stripe.userField) {
      logger.warn('Stripe integration attributes "userCollection" and "userField" are now deprecated, please use "mapping" attribute.');
      stripe.mapping = "".concat(stripe.userCollection, ".").concat(stripe.userField);
      delete stripe.userCollection;
      delete stripe.userField;
    }

    // Transform mapping to array
    if (_.isString(stripe.mapping)) {
      stripe.mapping = [stripe.mapping];
    }
  }
  function isMappingValid(stripe) {
    var models = modelsManager.getModels();
    var mappingValid = _.every(stripe.mapping, function (mappingValue) {
      var collectionName = mappingValue.split('.')[0];
      var fieldName = mappingValue.split('.')[1];
      if (!models[collectionName]) {
        return false;
      }

      // if sequelize -> false
      return !(models[collectionName].rawAttributes && !models[collectionName].rawAttributes[fieldName]);
    });
    if (!mappingValid) {
      logger.error("Cannot find some Stripe integration mapping values (".concat(stripe.mapping, ") among the project models:\n").concat(_.keys(models).join(', ')));
    }
    return mappingValid;
  }
  function isProperlyIntegrated(stripe) {
    var isValid = true;

    // Check apikey and stripe
    if (!stripe.apiKey) {
      logger.error('Stripe integration attribute "apiKey" is missing');
      isValid = false;
    }
    if (!stripe.stripe) {
      logger.error('Stripe integration attribute "stripe" is missing');
      isValid = false;
    }

    // Check that mapping is valid
    if (!Array.isArray(stripe.mapping)) {
      logger.error('Stripe integration attribute "mapping" is invalid');
      isValid = false;
    }
    return isValid && isMappingValid(stripe);
  }
  function integrationCollectionMatch(integration, model) {
    if (!integrationValid) {
      return false;
    }
    var models = modelsManager.getModels();
    var collectionModelNames = _.map(integration.mapping, function (mappingValue) {
      var collectionName = mappingValue.split('.')[0];
      if (models[collectionName]) {
        return Implementation.getModelName(models[collectionName]);
      }
      return null;
    });
    return collectionModelNames.indexOf(Implementation.getModelName(model)) > -1;
  }
  if (opts.integrations && opts.integrations.stripe) {
    upgradeIntegrationInPlace(opts.integrations.stripe);
    integrationValid = isProperlyIntegrated(opts.integrations.stripe);
  }
  this.defineRoutes = function (app, model) {
    if (!integrationValid) {
      return;
    }
    if (integrationCollectionMatch(opts.integrations.stripe, model)) {
      new Routes(app, model, Implementation, opts).perform();
    }
  };
  this.defineCollections = function (collections) {
    if (!integrationValid) {
      return;
    }
    _.each(opts.integrations.stripe.mapping, function (collectionAndFieldName) {
      Setup.createCollections(Implementation, collections, collectionAndFieldName);
    });
  };
  this.defineFields = function (model, schema) {
    if (!integrationValid) {
      return;
    }
    if (integrationCollectionMatch(opts.integrations.stripe, model)) {
      Setup.createFields(Implementation, model, schema.fields);
    }
  };
  this.defineSerializationOption = function (model, schema, dest, field) {
    if (integrationValid && field.integration === 'stripe') {
      dest[field.field] = {
        ref: 'id',
        attributes: [],
        included: false,
        nullIfMissing: true,
        // TODO: This option in the JSONAPISerializer is weird.
        ignoreRelationshipData: true,
        relationshipLinks: {
          related: function related(dataSet) {
            return {
              href: "/forest/".concat(Implementation.getModelName(model), "/").concat(dataSet[schema.idField], "/").concat(field.field)
            };
          }
        }
      };
    }
  };
}
module.exports = Checker;