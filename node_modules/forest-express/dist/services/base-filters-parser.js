"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var _ = require('lodash');
var _require = require('../utils/error'),
  InvalidFiltersFormat = _require.InvalidFiltersFormat;
var _require2 = require('../utils/schema'),
  getSmartField = _require2.getSmartField,
  isSmartField = _require2.isSmartField;

// NOTICE: Parse the given filters into a valid JSON.
var parseFiltersString = function parseFiltersString(filtersString) {
  if ((0, _typeof2["default"])(filtersString) === 'object') {
    return filtersString;
  }
  try {
    return filtersString ? JSON.parse(filtersString) : null;
  } catch (error) {
    throw new InvalidFiltersFormat('Invalid filters JSON format');
  }
};

// NOTICE: Apply the formatCondition function to a condition (leaf).
var parseCondition = /*#__PURE__*/function () {
  var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(condition, formatCondition, modelSchema) {
    var fieldFound, where, formattedCondition;
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          if (!_.isEmpty(condition)) {
            _context.next = 2;
            break;
          }
          throw new InvalidFiltersFormat('Empty condition in filter');
        case 2:
          if (_.isObject(condition)) {
            _context.next = 4;
            break;
          }
          throw new InvalidFiltersFormat('Condition cannot be a raw value');
        case 4:
          if (!_.isArray(condition)) {
            _context.next = 6;
            break;
          }
          throw new InvalidFiltersFormat('Filters cannot be a raw array');
        case 6:
          if (!(!_.isString(condition.field) || !_.isString(condition.operator) || _.isUndefined(condition.value))) {
            _context.next = 8;
            break;
          }
          throw new InvalidFiltersFormat('Invalid condition format');
        case 8:
          if (!(modelSchema && isSmartField(modelSchema, condition.field))) {
            _context.next = 21;
            break;
          }
          fieldFound = getSmartField(modelSchema, condition.field);
          if (fieldFound.filter) {
            _context.next = 12;
            break;
          }
          throw new Error("\"filter\" method missing on smart field \"".concat(fieldFound.field, "\""));
        case 12:
          _context.next = 14;
          return formatCondition(condition, true);
        case 14:
          where = _context.sent;
          _context.next = 17;
          return fieldFound.filter({
            where: where,
            condition: condition
          });
        case 17:
          formattedCondition = _context.sent;
          if (formattedCondition) {
            _context.next = 20;
            break;
          }
          throw new Error("\"filter\" method on smart field \"".concat(fieldFound.field, "\" must return a condition"));
        case 20:
          return _context.abrupt("return", formattedCondition);
        case 21:
          return _context.abrupt("return", formatCondition(condition));
        case 22:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function parseCondition(_x, _x2, _x3) {
    return _ref.apply(this, arguments);
  };
}();

// NOTICE: Call the formatAggregation function on the node and propagate it to its childs or
//         call the parseCondition function on the node if the node is a leaf.
var parseAggregation = /*#__PURE__*/function () {
  var _ref2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(node, formatAggregation, formatCondition, modelSchema) {
    var promises, formatedConditions;
    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          if (!_.isEmpty(node)) {
            _context2.next = 2;
            break;
          }
          throw new InvalidFiltersFormat('Empty condition in filter');
        case 2:
          if (_.isObject(node)) {
            _context2.next = 4;
            break;
          }
          throw new InvalidFiltersFormat('Filters cannot be a raw value');
        case 4:
          if (!_.isArray(node)) {
            _context2.next = 6;
            break;
          }
          throw new InvalidFiltersFormat('Filters cannot be a raw array');
        case 6:
          if (node.aggregator) {
            _context2.next = 8;
            break;
          }
          return _context2.abrupt("return", parseCondition(node, formatCondition, modelSchema));
        case 8:
          if (_.isArray(node.conditions)) {
            _context2.next = 10;
            break;
          }
          throw new InvalidFiltersFormat('Filters\' conditions must be an array');
        case 10:
          promises = [];
          node.conditions.forEach(function (condition) {
            return promises.push(parseAggregation(condition, formatAggregation, formatCondition, modelSchema));
          });
          _context2.next = 14;
          return Promise.all(promises);
        case 14:
          formatedConditions = _context2.sent;
          return _context2.abrupt("return", formatAggregation(node.aggregator, formatedConditions));
        case 16:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return function parseAggregation(_x4, _x5, _x6, _x7) {
    return _ref2.apply(this, arguments);
  };
}();

// NOTICE: Recursively call the formatAggregation function on the nodes of the filters tree and
//         propagate the formatCondition function to the leaves.
var perform = /*#__PURE__*/function () {
  var _ref3 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(filtersString, formatAggregation, formatCondition, modelSchema) {
    var filters;
    return _regenerator["default"].wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          filters = parseFiltersString(filtersString);
          if (filters) {
            _context3.next = 3;
            break;
          }
          return _context3.abrupt("return", null);
        case 3:
          return _context3.abrupt("return", parseAggregation(filters, formatAggregation, formatCondition, modelSchema));
        case 4:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
  return function perform(_x8, _x9, _x10, _x11) {
    return _ref3.apply(this, arguments);
  };
}();
var getConditionAssociation = function getConditionAssociation(condition) {
  var splittedField = condition.field.split(':');
  return splittedField.length > 1 ? splittedField[0] : null;
};
var aggregateAssociations = function aggregateAssociations(_aggregator, conditionsAssociations) {
  return _.flatten(conditionsAssociations);
};

// NOTICE: Recursively populate the associations names from the filters.
var getAssociations = /*#__PURE__*/function () {
  var _ref4 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4(filtersString) {
    var associations;
    return _regenerator["default"].wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          _context4.next = 2;
          return perform(filtersString, aggregateAssociations, getConditionAssociation);
        case 2:
          associations = _context4.sent;
          if (_.isArray(associations)) {
            _context4.next = 5;
            break;
          }
          return _context4.abrupt("return", associations ? [associations] : []);
        case 5:
          return _context4.abrupt("return", _.uniq(_.compact(associations)));
        case 6:
        case "end":
          return _context4.stop();
      }
    }, _callee4);
  }));
  return function getAssociations(_x12) {
    return _ref4.apply(this, arguments);
  };
}();
module.exports = {
  perform: perform,
  parseFiltersString: parseFiltersString,
  getAssociations: getAssociations,
  parseCondition: parseCondition
};