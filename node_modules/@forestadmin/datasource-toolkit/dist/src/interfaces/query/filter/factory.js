"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const luxon_1 = require("luxon");
const unpaginated_1 = __importDefault(require("./unpaginated"));
const collection_1 = __importDefault(require("../../../utils/collection"));
const schema_1 = __importDefault(require("../../../utils/schema"));
const factory_1 = __importDefault(require("../condition-tree/factory"));
const leaf_1 = __importDefault(require("../condition-tree/nodes/leaf"));
const projection_1 = __importDefault(require("../projection"));
class FilterFactory {
    static getPreviousConditionTree(field, startPeriod, endPeriod) {
        return factory_1.default.intersect(new leaf_1.default(field, 'GreaterThan', startPeriod.toISO()), new leaf_1.default(field, 'LessThan', endPeriod.toISO()));
    }
    static getPreviousPeriodByUnit(field, now, interval) {
        const dayBeforeYesterday = now.minus({ [interval]: 2 });
        return this.getPreviousConditionTree(field, dayBeforeYesterday.startOf(interval), dayBeforeYesterday.endOf(interval));
    }
    static getPreviousPeriodFilter(filter, timezone) {
        const now = luxon_1.DateTime.now().setZone(timezone);
        return filter.override({
            conditionTree: filter.conditionTree.replaceLeafs(leaf => {
                switch (leaf.operator) {
                    case 'Today':
                        return leaf.override({ operator: 'Yesterday' });
                    case 'Yesterday':
                        return this.getPreviousPeriodByUnit(leaf.field, now, 'day');
                    case 'PreviousWeek':
                        return this.getPreviousPeriodByUnit(leaf.field, now, 'week');
                    case 'PreviousMonth':
                        return this.getPreviousPeriodByUnit(leaf.field, now, 'month');
                    case 'PreviousQuarter':
                        return this.getPreviousPeriodByUnit(leaf.field, now, 'quarter');
                    case 'PreviousYear':
                        return this.getPreviousPeriodByUnit(leaf.field, now, 'year');
                    case 'PreviousXDays': {
                        const startPeriodXDays = now.minus({ days: 2 * Number(leaf.value) });
                        const endPeriodXDays = now.minus({ days: Number(leaf.value) });
                        return this.getPreviousConditionTree(leaf.field, startPeriodXDays.startOf('day'), endPeriodXDays.startOf('day'));
                    }
                    case 'PreviousXDaysToDate': {
                        const startPeriod = now.minus({ days: 2 * Number(leaf.value) });
                        const endPeriod = now.minus({ days: Number(leaf.value) });
                        return this.getPreviousConditionTree(leaf.field, startPeriod.startOf('day'), endPeriod);
                    }
                    case 'PreviousWeekToDate':
                        return leaf.override({ operator: 'PreviousWeek' });
                    case 'PreviousMonthToDate':
                        return leaf.override({ operator: 'PreviousMonth' });
                    case 'PreviousQuarterToDate':
                        return leaf.override({ operator: 'PreviousQuarter' });
                    case 'PreviousYearToDate':
                        return leaf.override({ operator: 'PreviousYear' });
                    default:
                        return leaf;
                }
            }),
        });
    }
    /**
     * Make a filter targeting the through collection of a many to many relationship from the relation
     * and a filter to the target collection.
     */
    static async makeThroughFilter(collection, id, relationName, caller, baseForeignFilter) {
        const relation = collection.schema.fields[relationName];
        const originValue = await collection_1.default.getValue(collection, caller, id, relation.originKeyTarget);
        const foreignRelation = collection_1.default.getThroughTarget(collection, relationName);
        // Optimization for many to many when there is not search/segment (saves one query)
        if (foreignRelation && baseForeignFilter.isNestable) {
            const baseThroughFilter = baseForeignFilter.nest(foreignRelation);
            return baseThroughFilter.override({
                conditionTree: factory_1.default.intersect(new leaf_1.default(relation.originKey, 'Equal', originValue), new leaf_1.default(relation.foreignKey, 'Present'), baseThroughFilter.conditionTree),
            });
        }
        // Otherwise we have no choice but to call the target collection so that search and segment
        // are correctly apply, and then match ids in the though collection.
        const target = collection.dataSource.getCollection(relation.foreignCollection);
        const records = await target.list(caller, await FilterFactory.makeForeignFilter(collection, id, relationName, caller, baseForeignFilter), new projection_1.default(relation.foreignKeyTarget));
        return new unpaginated_1.default({
            conditionTree: factory_1.default.intersect(
            // only children of parent
            new leaf_1.default(relation.originKey, 'Equal', originValue), 
            // only the children which match the conditions in baseForeignFilter
            new leaf_1.default(relation.foreignKey, 'In', records.map(r => r[relation.foreignKeyTarget]))),
        });
    }
    /**
     * Given a collection and a OneToMany/ManyToMany relation, generate a filter which
     * - match only children of the provided recordId
     * - can apply on the target collection of the relation
     */
    static async makeForeignFilter(collection, id, relationName, caller, baseForeignFilter) {
        const relation = schema_1.default.getToManyRelation(collection.schema, relationName);
        const originValue = await collection_1.default.getValue(collection, caller, id, relation.originKeyTarget);
        // Compute condition tree to match parent record.
        let originTree;
        if (relation.type === 'OneToMany') {
            // OneToMany case (can be done in one request all the time)
            originTree = new leaf_1.default(relation.originKey, 'Equal', originValue);
        }
        else {
            // ManyToMany case (more complicated...)
            const through = collection.dataSource.getCollection(relation.throughCollection);
            const throughTree = factory_1.default.intersect(new leaf_1.default(relation.originKey, 'Equal', originValue), new leaf_1.default(relation.foreignKey, 'Present'));
            const records = await through.list(caller, new unpaginated_1.default({ conditionTree: throughTree }), new projection_1.default(relation.foreignKey));
            originTree = new leaf_1.default(relation.foreignKeyTarget, 'In', records.map(r => r[relation.foreignKey]));
        }
        // Merge with existing filter.
        return baseForeignFilter.override({
            conditionTree: factory_1.default.intersect(baseForeignFilter.conditionTree, originTree),
        });
    }
}
exports.default = FilterFactory;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmFjdG9yeS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9pbnRlcmZhY2VzL3F1ZXJ5L2ZpbHRlci9mYWN0b3J5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsaUNBQStDO0FBRy9DLGdFQUFtQztBQUNuQywyRUFBd0Q7QUFDeEQsbUVBQWdEO0FBS2hELHdFQUE2RDtBQUU3RCx3RUFBNkQ7QUFDN0QsK0RBQXVDO0FBRXZDLE1BQXFCLGFBQWE7SUFDeEIsTUFBTSxDQUFDLHdCQUF3QixDQUNyQyxLQUFhLEVBQ2IsV0FBcUIsRUFDckIsU0FBbUI7UUFFbkIsT0FBTyxpQkFBb0IsQ0FBQyxTQUFTLENBQ25DLElBQUksY0FBaUIsQ0FBQyxLQUFLLEVBQUUsYUFBYSxFQUFFLFdBQVcsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxFQUNoRSxJQUFJLGNBQWlCLENBQUMsS0FBSyxFQUFFLFVBQVUsRUFBRSxTQUFTLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FDNUQsQ0FBQztJQUNKLENBQUM7SUFFTyxNQUFNLENBQUMsdUJBQXVCLENBQ3BDLEtBQWEsRUFDYixHQUFhLEVBQ2IsUUFBZ0I7UUFFaEIsTUFBTSxrQkFBa0IsR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRXhELE9BQU8sSUFBSSxDQUFDLHdCQUF3QixDQUNsQyxLQUFLLEVBQ0wsa0JBQWtCLENBQUMsT0FBTyxDQUFDLFFBQXdCLENBQUMsRUFDcEQsa0JBQWtCLENBQUMsS0FBSyxDQUFDLFFBQXdCLENBQUMsQ0FDbkQsQ0FBQztJQUNKLENBQUM7SUFFRCxNQUFNLENBQUMsdUJBQXVCLENBQUMsTUFBYyxFQUFFLFFBQWdCO1FBQzdELE1BQU0sR0FBRyxHQUFHLGdCQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBRTdDLE9BQU8sTUFB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