"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _toArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toArray"));
exports.getReferenceModel = function (options, reference) {
  var connections = options.connections;
  return Object.values(connections).reduce(function (models, connection) {
    return models.concat(Object.values(connection.models));
  }, []).find(function (model) {
    return exports.getModelName(model) === exports.getReferenceCollectionName(reference);
  });
};
exports.getReferenceField = function (reference) {
  return reference.split('.')[1];
};
exports.getReferenceCollectionName = function (reference) {
  return reference.split('.')[0];
};
exports.getModelName = function (model) {
  return model.modelName;
};

// TODO: Remove nameOld attribute once the lianas versions older than 2.0.0 are minority
exports.getModelNameOld = function (model) {
  return model.collection.name.replace(' ', '');
};
var getNestedFieldType = function getNestedFieldType(mongooseSchema, nestedFieldPath) {
  if (!mongooseSchema || !nestedFieldPath) return undefined;
  var _nestedFieldPath$spli = nestedFieldPath.split('.'),
    _nestedFieldPath$spli2 = (0, _toArray2["default"])(_nestedFieldPath$spli),
    currentFieldName = _nestedFieldPath$spli2[0],
    deepNestedFieldPath = _nestedFieldPath$spli2.slice(1);
  var nestedFieldDeclaration;
  if (mongooseSchema.tree) {
    nestedFieldDeclaration = mongooseSchema.tree[currentFieldName];
  } else if (mongooseSchema.type) {
    nestedFieldDeclaration = mongooseSchema.type[currentFieldName];
  } else {
    nestedFieldDeclaration = mongooseSchema[currentFieldName];
  }
  if (!nestedFieldDeclaration) return undefined;
  if (!deepNestedFieldPath.length) {
    return nestedFieldDeclaration.type || nestedFieldDeclaration;
  }
  return getNestedFieldType(nestedFieldDeclaration, deepNestedFieldPath === null || deepNestedFieldPath === void 0 ? void 0 : deepNestedFieldPath.join('.'));
};
exports.getNestedFieldType = getNestedFieldType;
exports.getMongooseSchemaFromFieldPath = function (fieldPath, model) {
  return model.schema.paths[fieldPath] || model.schema.singleNestedPaths[fieldPath] || null;
};